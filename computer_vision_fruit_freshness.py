# -*- coding: utf-8 -*-
"""Computer_Vision_Fruit_Freshness.ipynb

Automatically generated by Colab.

Original file is located at

#Fresh Fruit Classification (Fresh and Rotten)
"""

# All required modules are listed below please do pip install before working with this project
import  torch
from torch import nn
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from torch.utils.data import Dataset, DataLoader, TensorDataset
from sklearn.model_selection import train_test_split
from tqdm.auto import tqdm
import kagglehub
import tensorflow as tf
import torchvision.models as models
from torchvision.models import resnet50, ResNet50_Weights
from torchvision import transforms, datasets
import os
import labelme2coco
from dataset import FruitFreshnessDataset

from PIL import Image
from torch.utils.data import Dataset

# In case you are working with google colab or your cache get stucked
# please uncomment the code block below the restart session and run all again
# !rm -rf ~/.cache/torch/hub
# # !rm -rf ~/.cache/torch/checkpoints
# !pip install -U labelme2coco

# Downloade file from kaggle and remove this path to replace it with yours if you already have the dataset
Model_Path = kagglehub.dataset_download("abdulrafeyyashir/fresh-vs-rotten-fruit-images")
print("Path to dataset files:", Model_Path)

import os, glob, cv2
from google.colab.patches import cv2_imshow

dataset_root = Model_Path

print(os.listdir(dataset_root))

for ext in ('*.jpg','*.jpeg','*.png','*.zip'):
    files = glob.glob(os.path.join(dataset_root, '**', ext), recursive=True)
    if files:
        print('Found', len(files), 'images')

        random_image = np.random.choice(files)
        random_image_index = files.index(random_image)

        img = cv2.imread(files[random_image_index])
        cv2_imshow(img)

        break
else:
    print('No image files found â€“ maybe the dataset is shipped as a single archive?')

# restructure file to match up naming nomenclature

import pathlib
dataset_dir = pathlib.Path(dataset_root + "/" + "Fruit Freshness Dataset/Fruit Freshness Dataset")
dataset_dir

image_paths = list(dataset_dir.glob("*/*/*"))
image_paths = [str(path) for path in image_paths]

print(image_paths[:1])

# extracting labels from path
def parse_path(path):
  parts = tf.strings.split(path, "/")

  fruit = parts[-3]
  freshness = parts[-2]

  return fruit, freshness

# string to integer
fruit_lookup = tf.keras.layers.StringLookup()
freshness_lookup = tf.keras.layers.StringLookup()

fruit_labels = []
freshness_labels = []

for path in image_paths:
  f, fr = parse_path(path)
  fruit_labels.append(f)
  freshness_labels.append(fr)

fruit_lookup.adapt(fruit_labels)
freshness_lookup.adapt(freshness_labels)

print("Fruit classes:", fruit_lookup.get_vocabulary())
print("Freshness classes:", freshness_lookup.get_vocabulary())



# Adding Tranform to the images and also producing different transform on varyign epoches

# Note that the position you place you transfroms really tell how it will affect it occurence in the epochs
# if GaussianBlur is added at the last line it most likely all your images or 90% of it will be blurred

transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.GaussianBlur(kernel_size=(5, 9), sigma=(0.1, 5)),
    transforms.RandomHorizontalFlip(p=0.5),
    transforms.RandomVerticalFlip(p=0.5),
    transforms.RandomRotation(degrees=45),
    transforms.RandomAdjustSharpness(sharpness_factor=2, p=0.5),
    transforms.Normalize(
        mean=[0.485, 0.456, 0.406],
        std=[0.229, 0.224, 0.225]
    )
])


val_tf = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406],
                        std=[0.229, 0.224, 0.225])
])

# Sorting each fruit in line with it categorry and freshness

fruits = sorted(set([p.split(os.sep)[-3] for p in image_paths]))
freshness = sorted(set([p.split(os.sep)[-2] for p in image_paths]))

fruit_to_idx = {f: i for i, f in enumerate(fruits)}
freshness_to_idx = {f: i for i, f in enumerate(freshness)}

num_fruits = len(fruit_to_idx)
num_freshness = len(freshness_to_idx)

# # Splitting the dataset
from pathlib import Path

# The function below creates multiple overlap and duplicates and inturn produces overlap
# from sklearn.model_selection import train_test_split

# train_paths, val_paths = train_test_split(
#     image_paths, test_size=0.2, random_state=42, shuffle=True
# )

# print(f"Train size: {len(train_paths)}")
# print(f"Validation Size: {len(val_paths)}")

# train_names = {Path(p).stem for p in train_paths}
# val_names   = {Path(p).stem for p in val_paths}
# print('overlap:', len(train_names & val_names))
# print('train:', len(train_names), 'val:', len(val_names))


# The codes below is a cleaner version which doesn't produces overlap
path_df = pd.DataFrame({'path': image_paths})
path_df['stem'] = path_df['path'].apply(lambda p: Path(p).stem)

path_df = path_df.drop_duplicates(subset='stem')

train_paths, val_paths = train_test_split(
    path_df['path'].tolist(), test_size=0.2, random_state=42, shuffle=True)

train_names = {Path(p).stem for p in train_paths}
val_names   = {Path(p).stem for p in val_paths}
print('overlap:', len(train_names & val_names))   # must be 0
print('train:', len(train_names), 'val:', len(val_names))

train_ds = FruitFreshnessDataset(
    train_paths, fruit_to_idx, freshness_to_idx, transform
)

val_ds = FruitFreshnessDataset(
    val_paths, fruit_to_idx, freshness_to_idx, val_tf
)

img_tensor, label = train_ds[0]
img = img_tensor.permute(1, 2, 0)
img = img * torch.tensor([0.229, 0.224, 0.225]) + torch.tensor([0.485, 0.456, 0.406])
plt.imshow(img.clip(0, 1))
plt.title(label)

train_loader = DataLoader(train_ds, batch_size=32, shuffle=True, num_workers=0)
val_loader = DataLoader(val_ds, batch_size=32, shuffle=False, num_workers=0)

class FreshvsRotten(nn.Module):
  def __init__(self, num_classes, output_features):
    super().__init__()

    self.backbone = resnet50(weights=ResNet50_Weights.IMAGENET1K_V1)

    for param in self.backbone.parameters():
      param.requires_grad = False

    for param in self.backbone.layer4.parameters():
      param.requires_grad = True

    num_features = self.backbone.fc.in_features
    self.backbone.fc = nn.Identity()

    self.mlp = nn.Sequential(
        nn.Linear(num_features, 512),
        nn.BatchNorm1d(512),
        nn.SiLU(inplace=True),
        nn.Dropout(0.3)
    )

    self.fruit = nn.Sequential(
        # nn.Dropout(0.3),
        nn.Linear(512, 256),
        nn.ReLU(inplace=True),
        nn.Dropout(0.2),
        nn.Linear(256, num_classes)
    )

    self.freshness = nn.Sequential(
        # nn.Dropout(0.3),
        nn.Linear(512, 256),
        nn.ReLU(inplace=True),
        nn.Dropout(0.2),
        nn.Linear(256, output_features)
    )

  def forward(self, x):

    features = self.backbone(x)

    shared_features = self.mlp(features)

    fruit_output = self.fruit(shared_features)
    freshness_output = self.freshness(shared_features)

    return fruit_output, freshness_output


model = FreshvsRotten(num_classes=3, output_features=2)

# use the function call below to check the model components
# model

loss_fn_fruit = nn.CrossEntropyLoss()
loss_fn_freshness = nn.CrossEntropyLoss()

optimizer = torch.optim.Adam(model.parameters(), lr=1e-4, weight_decay=1e-3)

# Metrics calculator
def accuracy_fn(logits, y_pred):
  preds = torch.argmax(logits, dim=1)
  return (preds == y_pred).float().mean().item()

# Train and Test Loop

device = "cuda" if torch.cuda.is_available() else "cpu"
model.to(device)
print(device)

epochs = 20
training_loss_array = []
testing_loss_array = []
training_accuracy_fresh_acc, training_accuracy_fruit_acc = [], []
testing_accuracy_fresh_acc, testing_accuracy_fruit_acc = [], []

for epoch in tqdm(range(epochs)):

  model.train()
  training_loss = 0
  num_of_samples = 0
  running_loss = 0
  training_accuracy_fresh = 0
  training_accuracy_fruit = 0

  epoch_training_loss = 0

  for X, (y_fruit_pred, y_freshness_pred) in train_loader:
    X, y_fruit_pred , y_freshness_pred = X.to(device), y_fruit_pred.to(device), y_freshness_pred.to(device)


    fruit_pred, freshness_pred = model(X)

    fruit_loss = loss_fn_fruit(fruit_pred, y_fruit_pred)
    freshness_loss = loss_fn_freshness(freshness_pred, y_freshness_pred)

    loss = fruit_loss + freshness_loss

    optimizer.zero_grad()

    loss.backward()

    optimizer.step()
    batch_size = X.size(0)
    running_loss += loss.item() * batch_size
    num_of_samples += batch_size
    training_accuracy_fresh += accuracy_fn(freshness_pred, y_freshness_pred) * batch_size
    training_accuracy_fruit += accuracy_fn(fruit_pred, y_fruit_pred) * batch_size



  training_accuracy_fresh_acc.append(training_accuracy_fresh / num_of_samples)
  training_accuracy_fruit_acc.append(training_accuracy_fruit / num_of_samples)
  epoch_training_loss += running_loss / num_of_samples
  training_loss_array.append(epoch_training_loss)



  model.eval()

  testing_loss = 0
  num_of_test_samples = 0
  test_running_loss = 0
  epoch_test_loss = 0
  test_accuracy_fresh = 0
  test_accuracy_fruit = 0
  with torch.inference_mode():

    for  X, (y_fruit_pred, y_freshness_pred) in (val_loader):
      X, y_fruit_pred , y_freshness_pred = X.to(device), y_fruit_pred.to(device), y_freshness_pred.to(device)
      test_fruit_pred, test_freshness_pred = model(X)
      freshness_loss = loss_fn_freshness(test_freshness_pred, y_freshness_pred)
      fruit_loss = loss_fn_fruit(test_fruit_pred, y_fruit_pred)
      test_loss = fruit_loss + freshness_loss

      batch_size = X.size(0)
      num_of_test_samples += batch_size
      test_running_loss += test_loss.item() * batch_size
      test_accuracy_fresh += accuracy_fn(test_freshness_pred, y_freshness_pred) * batch_size
      test_accuracy_fruit += accuracy_fn(test_fruit_pred, y_fruit_pred) * batch_size

  testing_accuracy_fresh_acc.append(test_accuracy_fresh / num_of_test_samples)
  testing_accuracy_fruit_acc.append(test_accuracy_fruit / num_of_test_samples)
  epoch_test_loss += test_running_loss / num_of_test_samples

  testing_loss_array.append(epoch_test_loss)
  print(
        f"Epoch [{epoch+1}/{epochs}] | "
        f"Train Loss: {epoch_training_loss:.4f} | "
        f"Val Loss: {epoch_test_loss:.4f}"
    )


print(f"Traing loss array : {training_loss_array}")
print(f"Testing loss array : {testing_loss_array}")
print(f"Fresh Testing Accuracy Array  :{test_accuracy_fresh}")
print(f"Fruit Testing Accuracy Array  :{test_accuracy_fruit}")
print(f"Fresh Training Accuracy Array  :{training_accuracy_fresh}")
print(f"Fruit Training Accuracy Array  :{training_accuracy_fruit}")

# Plotting the curve

epoch_range = range(1, epochs +1)

plt.figure(figsize=(12,6))
plt.subplot(1,2,1)
plt.plot(epoch_range, training_loss_array)
plt.plot(epoch_range, testing_loss_array)
plt.title("Training and Testing Loss")
plt.legend(["Training Loss", "Testing Loss"])
plt.xlabel("Epoch")
plt.ylabel("loss")

plt.subplot(1,2,2)
plt.plot(epoch_range, training_accuracy_fresh_acc)
plt.plot(epoch_range, testing_accuracy_fresh_acc)
plt.title("Training and Testing Accuracy Fresh Fruit")
plt.legend(["Training Accuracy", "Testing Accuracy"])
plt.xlabel("Epoch")
plt.ylabel("Accuracy")
plt.show()

plt.subplot(2,2,1)
plt.plot(epoch_range, training_accuracy_fruit_acc)
plt.plot(epoch_range, testing_accuracy_fruit_acc)
plt.title("Training and Testing Accuracy Fruit Type")
plt.legend(["Training Accuracy", "Testing Accuracy"])
plt.xlabel("Epoch")
plt.ylabel("Accuracy")
plt.show()
